# 封装

核心思想: 合理隐藏, 合理暴露

1. 如何隐藏: 使用private关键字修饰成员变量,这样就只能在本类中访问了
2. 如何暴露 : 使用public的get()和set()方法----取值和赋值

面向对象的三大特征:封装 继承 多态

# Javabean(实体类)

要求1: 满足封装(private成员变量 public的getter和setter方法)

要求2: 需要提供一个无参构造器, 有参构造器可选

只负责数据存取, 不考虑操作

应用场景:

![image-20250202105507160](https://pic-aoliaoduo.s3.bitiful.net/image-20250202105507160.png)

# static

可以修饰成员变量和成员方法



## 修饰成员变量

static---静态变量(类变量)

不带static---实例变量(对象变量)

同一个类中访问静态变量可以直接省略类名不写

**原理图**

![image-20250204143206299](https://pic-aoliaoduo.s3.bitiful.net/image-20250204143206299.png)

**应用场景**

![image-20250204143652341](https://pic-aoliaoduo.s3.bitiful.net/image-20250204143652341.png)

## 修饰方法

分为静态方法和实例方法

**静态方法应用场景:** 只是为了做一个功能, 且不需要访问对象的数据, 例如生成验证码!(工具类)

---

同一个类中访问静态方法也可以直接省略类名不写

例如main方法下面的静态方法, 在main方法中调用时可以省略类名, 直接写方法名

main方法也是类方法, 官方直接用 ``类名.main()``来调用的

---

工具类没有创建对象的需要, 所以构造器可以私有private

# 静态方法的注意事项

变量和方法都属于成员

成员包括

1. 变量
2. 方法
3. 构造器
4. 初始化块
5. 内部类

注意事项

1. 静态方法中可以直接访问静态成员 不可以直接访问实例成员(可以间接访问)
2. 实例方法中可以直接访问静态成员 也可以直接访问实例成员
3. 静态方法中不可以出现this关键字, 实例方法中可以出现this关键字(因为this表示当前对象)



# 综合实战1

![image-20250204153041823](https://pic-aoliaoduo.s3.bitiful.net/image-20250204153041823.png)

Test.java

```java
package com.aoli.oop.demo;

public class Test {
    public static void main(String[] args) {
        Movie[] movies = new Movie[6];
        movies[0] = new Movie(1, "《大话西游》", 9.9, "周星驰");
        movies[1] = new Movie(2, "《霸王别姬》", 9.7, "陈凯歌");
        movies[2] = new Movie(3, "《活着》", 9.6, "张艺谋");
        movies[3] = new Movie(4, "《无间道》", 9.3, "刘伟强");
        movies[4] = new Movie(5, "《哪吒之魔童降世》", 8.7, "饺子");
        movies[5] = new Movie(6, "《我不是药神》", 8.9, "文牧野");

        MovieOperator movieOperator = new MovieOperator(movies);
        movieOperator.printAllMovies();
        movieOperator.searchMoviesById();

    }
}

```



Movie.java

```java
package com.aoli.oop.demo;

public class Movie {
    private int id;
    private String name;
    private double price;
    private String actor;

    public Movie() {

    }

    public Movie(int id, String name, double price, String actor) {
        this.id = id;
        this.name = name;
        this.price = price;
        this.actor = actor;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    public String getActor() {
        return actor;
    }

    public void setActor(String actor) {
        this.actor = actor;
    }
}

```



MovieOperator.java

```java
package com.aoli.oop.demo;

import java.util.Scanner;

public class MovieOperator {
    private Movie[] movies;

    public MovieOperator(Movie[] movies) {
        this.movies = movies;
    }

    public void printAllMovies() {
        System.out.println("========================全部电影信息=========================");
        for (int i = 0; i < movies.length; i++) {
            Movie m = movies[i];
            System.out.println(m.getId() + "\t" + m.getName() + "\t" + m.getPrice() + "\t" + m.getActor());
        }
    }

    public void searchMoviesById() {
        System.out.println("========================按编号查询=========================");
        System.out.println("请输入要查询的电影编号：");
        int id = new Scanner(System.in).nextInt();
        for (int i = 0; i < movies.length; i++) {
            Movie m = movies[i];
            if (m.getId() == id) {
                System.out.println(m.getId() + "\t" + m.getName() + "\t" + m.getPrice() + "\t" + m.getActor());
                return;
            }
        }
        System.out.println("没有找到该电影");
    }
}

```

# 继承

关键字:extends

- 子类能继承父类的非私有成员

- 子类对象是由子类和父类多张设计图共同创建出来的

## 权限修饰符

限制类中的成员能被访问的范围

- private: 只能本类
- 缺省: 本类, 同一个包中的类
- protected: 本类, 同一个包中的类, 子孙类
- public: 任意位置

**注意:** 无法在static方法里调用其他static方法

## 继承的特点

- 单继承
- 多层继承
- 祖宗类: Object
- 就近原则(优先局部, 然后自己类, 自己类没有再找父类)

**注意:**  一个java文件中可以有多个类, 但是public类只能有一个, 文件名也是public类的类名

**Q: java的类为什么不支持多继承**

A: 用反证法, 例如两个method(分别来自两个父类), 则不知道运行哪个

---

Q: 如果子父类中出现重名成员  则优先使用子类的, 那么如果想强行使用父类的成员该怎么办?

A : 使用super关键字

## 方法重写

核心:声明不变, 重新实现

子类重写父类的方法

@Override---方法重写的校验注解(标志)



其他注意事项:

1. 子类重写父类方法时, 权限要大于等于父类该**方法**的权限
2. 重写的**返回值类型**要小于等于被重写方法的返回值类型
3. 私有方法和静态方法不能被重写(原因: 私有成员不能被继承)



